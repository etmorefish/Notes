- 快速排序原理

  ```sh
  1．先从数列中取出一个数作为基准数。
  2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
  3．再对左右区间重复第二步，直到各区间只有一个数。
  最本质的总结:
  快速排序,说白了就是给基准数据找其正确索引位置的过程.
  ```

- map底层原理

  ```sh
  数组 + 链表
  根据键（Key）而直接访问在内存存储位置的数据结构
  哈希表用的是数组支持按照下标随机访问数据的特性，所以哈希表其实就是数组的一种扩展，由数组演化而来
  哈希表存储的是由键（key）和值（value）组成的数据。
  
  自己实现一个
  1.设计一个好的哈希函数。
      整型数据的哈希函数。
      字符串的哈希函数。
      自定义类型的哈希函数。
      集合的哈希函数。
  2.解决哈希冲突的办法。
      开放地址法
          线性探测
          二次探测
          随机数探测
      再哈希法
      链地址地址法
  3.扩容方法
  ```

- 遇到查询语句慢 如何排查

  ```sh
  1. 慢查询的数量保存在mysql库里面的slow_log表。
  	SELECT * FROM slow_log where start_time
  2.查看当前进行的查询状态
      比如查看当前所有的process
      select * from information_schema.processlist 
  3.通过在SQL语句前加上explain命令，来显示这句SQL语句的执行计划。
      我们可以分析出以下结果：
  
      表的读取顺序
      数据读取操作的操作类型
      哪些索引可以使用
      哪些索引被实际使用
      表之间的引用
      每张表有多少行被优化器查询
  4.如何优化慢查询
      当通过排查定位到慢查询sql后，就需要通过explain命令分析sql的执行计划并进行相应的优化
  
      如果是因为没走索引，就要建合适的索引
      因为mysql查询优化器会误使用非预期索引导致语句查询缓慢，这时候需要修改sql逻辑引导优化器使用正确的索引，或者强制（force index）使用我们预期的索引
      如果是因为数据表太大，即使走了索引也依然很慢，这时要考虑分表
  
  ```

 - 使用原则

   ```sh
     通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
     对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
     数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历
     索引的时间还要短，索引就可能不会产生优化效果。
     在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
   ```

   
