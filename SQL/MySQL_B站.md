# MySQL B站

##  0. B树和B+树之间的区别是什么?
```text
1、一个节点里面有多个元素
2、元素有排序
3、叶子节点之间有指针
4、非叶子节点上面的元素都冗余了一份在叶子上面
```

##  1. Innodb中的B+树是怎么产生的?
```text

```

##  2. 高度为3的B+树能存多少条数据?
```text
每页 16kb 一个主键int 4字节，一个指针6字节，假设每条记录1kb
4b + 6b = 10b
16kb/10b = 1638 页
1638 * (16kb/1kb) = 26,208 条   两层
1638 * 1638 * (16kb/1kb) = 42,928,704   三层

```

##  3. Innodb是如何支持范围查找能走索引的?
```text
B+ 树就是主键索引，索引和数据存在一起，就叫做聚簇索引
eg：select * from a>6 ; 先找到a=6，在返回右边的数据。

```

##  4. 为什么要遵守最左前缀原则才能利用到索引?
```text
create index idx_t1_bcd on t1(b,c,d);  -- t1表创建bcd联合索引

explain select b from t1 order by b,c,d;  -- 走索引
                                        -- 全部扫描 额外排序（内存） + 不用回表
主要看查询条件有没有给最左边的那个条件b，如果没有则无法走索引
explain select * from t1 where b=1 and c=1 and d=1; -- 走索引，有b

```

##  5. 范围查找导致索引失效原理分析?
```text
对于任何一个sql，既可以走索引，有可以走全表扫描

explain select * from t1 where b>1;  -- 不走索引，没有全表扫描快

条件要越精确越好，
```

##  6. 覆盖索引的底层原理?
```text
sql里面查询的字段正好在所在的索引中，就可以直接返回，不用在全表扫描
explain select b from t1 where b>1;  -- 走索引
explain select b,c,d,a from t1 where b>1;  -- 走索引,因为a是主键，他存在在bcd的叶子节点下面，都属于覆盖索引
explain select b,c,d,a,e from t1 where b>1;  -- 不走索引,因为e不在bcd所索引树上面只能回表
```

##  7. 索引扫描底层原理?
```text
explain select b from t1;  -- 走bcd索引，可以全表扫描返回 
        -- 从主键索引的叶子节点去遍历，完整数据
        -- 也可以走bcd索引的叶子节点区遍历，不完整数据，只是遍历的数据不一样

```

##  8. order by为什么会导致索引失效?
```text
explain select * from t1 order by b,c,d;  -- 走bcd索引，取出来的数据不需要排序，需要回表 慢
                                        -- 全部扫描 额外排序（内存） + 不用回表 快
explain select b from t1 order by b,c,d;  -- 走bcd索引，不需排序，不需回表
                                        -- 全部扫描 额外排序（内存） + 不用回表
```

##  9. mysql中的数据类型转换有哪些要注意的?
```text
字符串作为索引 e 是varchar
-- 把字符串转化为0,将数字字符串转化为数字

select 'a'=0;  -- 1 等式左右两边相等
select 'b'=1;  -- 0 等式左右两边不相等
select '123'=123; -- 1
```

##  10. 对字段进行操作导致索引失效原理?
```text
explain select * from t1 where e = 1; -- 0  改字段，索引失效，查不到数据
```

##  11. 二叉搜索树和平衡二叉树有什么关系?
```text
平衡二叉树也叫平衡二叉搜索树，是二叉树的升级版，
二叉搜索树是指节点左边的所有节点都比该节点小，节点右边的节点都比该节点大，
而平衡二叉树是在二叉搜索树的基础上还规定了节点两边的子树高度差的绝对值不能超过1
```

##  12. 强平衡二叉树和弱平衡二叉树有什么区别?
```text
强平衡二叉树AVL树，弱平衡二叉树就是我们说的红黑树。
1、AVL树比红黑树对于平衡的程度更加严格，在相同的节点情况下，AVL树的高度低于红黑树
2、红黑树中增加了一个节点颜色的概念
3、AVL树的旋转操作比红黑树的旋转操作更加耗时
```

##  13. B树和B+树的区别，为什么Mysql使用B+树?
```text
B树的特点：
    1、节点排序
    2、一个节点村多个元素，多个元素也排序了

B+树的特点：
    1、拥有B树的特点
    2、叶子节点之间有指针
    3、非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所有的元素，并且排好顺序

MySQL索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序，所以是可以提高查询速度的，
然后通过一个节点中可以存储多个元素，从而可以使得B+树的高度不会太高，在MySQL中一个Innodb页就是一个B+树节点，
一个Innodb页默认16kb，所以一般情况下一颗两层的B+树可以存2000万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等SQL语句。
```

##  14. epoll和poll的区别?
```text
1、select模型，使用的是数组来存储Socket连接描述文件符，容量是固定的，需要通过轮询来判断是否发生了IO事件
2、poll模型，使用的是链表来存储Socket连接描述文件符，容量是不固定的，需要通过轮询来判断是否发生了IO事件
3、epoll模型，epoll和poll是完全不同的，epoll是一种事件通知模型，当发生了IO事件时，应用程序才进行IO操作，不需要像poll模型那样主动去轮询
```

##  15. Mysql的锁你了解哪些?
```text
按锁的粒度划分：
    1、行锁：锁某行数据，锁粒度最小，并发度高
    2、表锁：锁整张表，锁粒度大，并发度低
    3、间隙锁：锁的是一个区间
或者：
    1、共享锁：也就是读锁，一个事务给某行数据加了读锁，其他事务也可以读，但是不能写
    2、排他锁：也就是写锁，一个事务给某行数据加了读锁，其他事务也不能读，也不能写
或者：
    1、乐观锁：并不会真正的去锁某行记录，而是通过一个版本号来实现的
    2、悲观锁：上面的行锁，表锁等都是悲观锁
在事务的隔离级别实现中，就需要利用锁来解决幻读
```

##  16. 最左前缀原则是什么?
```text
当一个SQL想要利用索引时就一定要提供该索引对应的字段中的最左边的字段，也就是排在最前面的字段，
比如针对abc三个字段建立一个联合索引，那么在写一个sql时就一定要提供a字段的条件，这样才能用到联合索引，这是由于在建立abc三个字段的联合索引时，底层的B+树是按照abc三个字段从左到右去比较大小进行排序的，所以如果利用B+树进行快速查找也得符合这个规则
```

##  17. Mysql慢查询该如何优化?
```text
1、检查时候走了索引，如果没有则优化SQL利用索引
2、检查所利用的索引，是否是最优索引
3、检查所查字段时候都是必须的，是否查询了过多的字段，查出了多余的数据
4、检查表中的数据是否过多，是否该进行分库分表了
5、检查数据库实例所在的机器的性能配置，是否太低，是否可以适当增加资源
```

##  18. Mysql中有哪些存储引擎?
```text
InnoDB存储引擎
    是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。
    它被设计用来处理大量的短期（short-lived）事务，应该优先考虑Innodb引擎。
MyISAM存储引擎
    在MySQL 5.1 及之前的版本，MyISAM是默认的存储引擎。
    但是MyISAM不支持事务和行级锁，而且崩溃后无法安全恢复。
    同时MyISAM对整张表加锁，很容易因为表锁的问题导致典型的性能问题。
Memory引擎
Archive引擎
CSV引擎
```

##  19. MyISAM和InnoDB的区别是什么?
```text
1、InnoDB支持事务，MyISAM不支持事务。
    这是MySQL将默认存储引擎从MyISAM变成InnoDB的重要原因之一
2、InnoDB支持外键，而MyISAM不支持。
    对一个包含外键的InnoDB表转化为myisam会失败
3、InnoDB是聚集索引，myisam是非聚集索引
    聚簇索引的文件存放在主键索引的叶子节点上因此InnoDB必须要有主键，通过主键索引效率很。但是辅助索引需要两次查询，先查询主键查询到的数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。
    而myisam是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4、InnoDB不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。
    而myisam用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。
5、InnoDB最小的锁的粒度是行锁，myisam最小的粒度是表锁。
    一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这是MySQL将默认存储引擎从MyISAM变成InnoDB的重要原因之一
```

##  20. 数据表设计时，字段你会如何选择?
```text

```

##  21. Mysql中VARCHAR(M)最多能存储多少数据?
```text

```

##  22. 请说下事务的基本特性?
```text
事务基本特性ACID分别是：

- 原子性 指的是一个事务中的操作要么全部成功，要么全部失败。
- 一致性 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证
- 隔离性 指的是一个事务的修改在最终提交前，对其他事务是不可见的。
- 持久性 指的是一旦事务提交，所做的修改就会永久保存到数据库中。

隔离性有4个隔离级别，分别是：

- read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。
    用户本来应该读取到id=1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age=20，这就是脏读。
- read commit 读已提交，两次读取结果不一致，叫做不可重复读。
    不可重复读解决了脏读的问题，他只会读取已经提交的事务。用户开启事务读取id=1用户，查询到age=10，再次读取发现结果=20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。
- repeatable read 可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。
- serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。

脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。
```

##  23. 事务并发可能引发什么问题?
```text

```

##  24. 简单描述下Mysql各种索引?
```text
普通索引：允许被索引的数据列包含重复的值。
唯一索引：可以保证数据记录的唯一性。
主键：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。
联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。
全文索引：通过建立 倒排索引 ,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引

索引可以极大的提高数据的查询速度。
通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。
```

##  25. 什么是三星索引?
```text

```

##  26. InnoDB一颗B+树可以存放多少行数据?
```text

```

##  27. Mysq如何实现读写分离?
```text

```

##  28. Mysq如何实现分库分表?
```text
    将原本存储于单个数据库上的数据拆分到多个数据库，把原本存储在单张数据表的数据拆分到多张数据表中，实现数据切分，从而提升数据库的操作性能。分库分表的实现可以分为两种方式：
水平分库分表：
    将数据分散到多张表，涉及分区键
    每个库结构一样，数据不一样，没有交集。库多了可以缓解io和cpu的压力
    每个表结构一样，数据不一样，没有交集。表数量减少可以提高sql执行效率、减轻cpu压力
垂直分库分表：
    将字段拆分为多张表，需要一定的重构
    每个库结构、数据都不一样，所有库的并集为全量数据
    每个表结构、数据不一样，至少有一列交集，用于关联数据，所有表的并集为全量数据
```

##  29. mysql索引结构，各自的优劣?
```text
索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，InnoDB存储引擎的默认索引实现为：B+树索引。
对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

B+树：B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。

哈希索引：哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；

哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；哈希索引也不支持多列联合索引的最左匹配规则；B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。
```

## 30. 存储拆分后如何解决唯一主键问题？
```text
UUID： 简单、性能好、没有顺序、没有业务含义、存在泄露mac地址的风险
数据库主键：实现简单、单调递增、具有一定的业务可读性、强依赖db、存在性能瓶颈、存在暴露业务信息的风险
redis、mongodb，zk等中间件：增加了系统的复杂度和稳定性
雪花算法
```

## 索引设计的原则？
```text
查询更快、占用空间更小

1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
2. 基数较小的表，索引效果较差，没有必要在此列建立索引
3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，
如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进
行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
5. 定义有外键的数据列一定要建立索引。
6. 更新频繁字段不适合创建索引
7. 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
8. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修
改原来的索引即可。
9. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
10. 对于定义为text、image和bit的数据类型的列不要建立索引。
```

## Mysql主从同步原理

```text
mysql主从同步的过程：

Mysql的主从复制中主要有三个线程：
master（binlog dump thread）、slave（I/O thread、SQL thread） ，Master一条线程和Slave中的两条线程。

- 主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。
- 主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。
- 从节点 I/O线程接收 binlog 内容，并将其写入到 relay log 文件中。
- 从节点的SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。

注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。
由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。

全同步复制
    主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。
半同步复制
    和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。
```

## 快速排序原理

```sh
1．先从数列中取出一个数作为基准数。
2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3．再对左右区间重复第二步，直到各区间只有一个数。
最本质的总结:
快速排序,说白了就是给基准数据找其正确索引位置的过程.
```

## map底层原理

```sh
数组 + 链表
根据键（Key）而直接访问在内存存储位置的数据结构
哈希表用的是数组支持按照下标随机访问数据的特性，所以哈希表其实就是数组的一种扩展，由数组演化而来
哈希表存储的是由键（key）和值（value）组成的数据。

自己实现一个
1.设计一个好的哈希函数。
    整型数据的哈希函数。
    字符串的哈希函数。
    自定义类型的哈希函数。
    集合的哈希函数。
2.解决哈希冲突的办法。
    开放地址法
        线性探测
        二次探测
        随机数探测
    再哈希法
    链地址地址法
3.扩容方法
```

## 遇到查询语句慢 如何排查

```sh
1. 慢查询的数量保存在mysql库里面的slow_log表。
	SELECT * FROM slow_log where start_time
2.查看当前进行的查询状态
    比如查看当前所有的process
    select * from information_schema.processlist 
3.通过在SQL语句前加上explain命令，来显示这句SQL语句的执行计划。
    我们可以分析出以下结果：

    表的读取顺序
    数据读取操作的操作类型
    哪些索引可以使用
    哪些索引被实际使用
    表之间的引用
    每张表有多少行被优化器查询
4.如何优化慢查询
    当通过排查定位到慢查询sql后，就需要通过explain命令分析sql的执行计划并进行相应的优化

    如果是因为没走索引，就要建合适的索引
    因为mysql查询优化器会误使用非预期索引导致语句查询缓慢，这时候需要修改sql逻辑引导优化器使用正确的索引，或者强制（force index）使用我们预期的索引
    如果是因为数据表太大，即使走了索引也依然很慢，这时要考虑分表

```

## 使用原则

```sh
  通过优缺点对比，不是索引越多越好，而是需要自己合理的使用。
  对经常更新的 表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，
  数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历
  索引的时间还要短，索引就可能不会产生优化效果。
  在一字段上相同值比较多不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。
```



## **如何利用RabbitMQ实现延时队列**

```sh
死信队列+TTL过期时间来实现延迟队列
延迟队列的插件
```

## 如何简单实现接口限流

```
采用计数器实现限流有点简单粗暴，一般我们会限 制一秒钟的能够通过的请求数，比如限流qps为100，算法的实现思路就是从第一个请求进来开始计时，在接下去的1s内，每来一个请求，就把计数加1，如果累加的数字达到了100，那么后续的请求就会被全部拒绝。而且这个计数器只能保存在第三方服务，比如redis
```

